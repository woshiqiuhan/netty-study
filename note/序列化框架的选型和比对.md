# 序列化框架的比对

## 序列化、反序列化

序列化、反序列化，即编解码

- 编码(Encode)：序列化(Serialization)，即**将对象序列化成字节数组**，用于网络传输、数据持久化或其他用途
- 解码(Decode)：反序列化(Deserialization)，**把从网络、磁盘等读取到的字节数组还原成原始对象**(通常是原始对象的**拷贝**)

网络通信流程

1. 客户端将需要请求的数据封装好了之后就需要进行转换为二进制格式再转换为流进行传输
2. 服务端接收到流之后再将数据解析为二进制格式的内容，再按照约定好的协议进行处理解析

最常见的场景就是 rpc 远程调用的时候，对**发送数据和接收数据时候的处理**

结下来介绍几款当前比较常见的**序列化技术框架**

## 序列化技术框架

准备一个序列化对象

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class POJO implements Serializable { // 实现 Serializable 接口，表示当前类可被序列化
    /**
     * 设置 serialVersionUID 序列化ID的作用
     *     序列化操作时会将当前类声明的 serialVersionUID 写入到序列化文件中，
     *  反序列化时会对比文件中的 serialVersionUID 与类的 serialVersionUID 是否相同，
     *  如果相同则序列化成功，否则失败，该操作用于保证版本一致。
     * 注：若未显示声明 serialVersionUID，序列化时会根据类生成一个存入文件中，
     *    若类被修改过则 serialVersionUID 会改变
     */
    private static final long serialVersionUID = -2640724836289593418L;

    private Integer id;
    private String name;
    private Boolean flag;

    /**
     * 使用 transient 关键词修饰，代表该属性不需要序列化
     * 该对象在反序列化出来结果之后，相应的属性就会为null值
     */
    private transient Integer notSerializable;
}
```

### JDK 自带序列化

JDK 自身便带有序列化与反序列化的功能，具体的分析如下：

- 序列化反序列化

  ```java
  // 序列化
  ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(fileName));
  oos.writeObject(pojo);
  
  // 反序列化
  ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName));
  pojo = (POJO) ois.readObject();
  ```

- 性能测试

  ```java
  public class SerializationTest {
      public static void main(String[] args) throws IOException, ClassNotFoundException {
          String fileName = "TestPOJOJDK.txt";
          POJO pojo = new POJO(
                  UUID.randomUUID().getLeastSignificantBits(),
                  "Hello", false, 2);
  
          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(fileName));
          ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName));
  
          // 序列化
          long start = System.currentTimeMillis();
          for (int i = 0; i < 1000000; i++) {
              oos.writeObject(pojo);
          }
          System.out.println("序列化用时：" + (System.currentTimeMillis() - start) + "ms");
  
          // 反序列化
          start = System.currentTimeMillis();
          for (int i = 0; i < 1000000; i++) {
              pojo = (POJO) ois.readObject();
          }
          System.out.println("反序列化用时：" + (System.currentTimeMillis() - start) + "ms");
      }
  }
  
  /*
  输出：
  	序列化用时：1448ms
  	反序列化用时：929ms
  */
  ```

存在的问题：

1. **无法跨语言**
2. **序列后的码流太大**
3. **序列化性能太低**

## Hessian 序列化框架

Hessian 是一款支持**多语言**的序列化操作的框架技术

具体的分析如下：

- 序列化反序列化

  ```java
  // 序列化
  HessianOutput hos = new HessianOutput(new FileOutputStream(fileName));
  hos.writeObject(pojo);
  
  // 反序列化
  HessianInput his = new HessianInput(new FileInputStream(fileName));
  pojo = (POJO) his.readObject();
  ```

- 性能测试

  ```java
  public class SerializationTest {
      public static void main(String[] args) throws IOException, ClassNotFoundException {
          String fileName = "TestPOJOJDK.txt";
          POJO pojo = new POJO(
                  UUID.randomUUID().getLeastSignificantBits(),
                  "Hello", false, 2);
  
          HessianOutput hos = new HessianOutput(new FileOutputStream(fileName));
          HessianInput his = new HessianInput(new FileInputStream(fileName));
  
          long start = System.currentTimeMillis();
          for (int i = 0; i < 1000000; i++) {
              // 序列化
              hos.writeObject(pojo);
          }
          System.out.println("序列化用时：" + (System.currentTimeMillis() - start) + "ms");
  
          start = System.currentTimeMillis();
          for (int i = 0; i < 1000000; i++) {
              // 反序列化
              pojo = (POJO) his.readObject();
          }
          System.out.println("反序列化用时：" + (System.currentTimeMillis() - start) + "ms");
      }
  }
  
  /*
  输出：
    序列化用时：6651ms
    反序列化用时：2003ms
  */
  ```

存在的问题：

1. **速度慢**



## 总结

|                        | **优点**                                 | **缺点**                                                     |
| ---------------------- | ---------------------------------------- | ------------------------------------------------------------ |
| **Kryo**               | 速度快，序列化后体积小                   | 跨语言支持较复杂                                             |
| **Hessian**            | 默认支持跨语言                           | 较慢                                                         |
| **Protostuff**         | 速度快，基于protobuf                     | 需静态编译                                                   |
| **Protostuff-Runtime** | 无需静态编译，但序列化前需预先传入schema | 不支持无默认构造函数的类，反序列化时需用户自己初始化序列化后的对象，其只负责将该对象进行赋值 |
| **Java-JDK**           | 使用方便，可序列化所有类                 | 速度慢，占空间                                               |

